// "hello world"
wf := import("@platforma-sdk/workflow-tengo:workflow")
exec := import("@platforma-sdk/workflow-tengo:exec")
assets:= import("@platforma-sdk/workflow-tengo:assets")
xsv := import("@platforma-sdk/workflow-tengo:pframes.xsv")
pframes := import("@platforma-sdk/workflow-tengo:pframes")
maps := import("@platforma-sdk/workflow-tengo:maps")
slices := import("@platforma-sdk/workflow-tengo:slices")
render := import("@platforma-sdk/workflow-tengo:render")
clusteringTpl := assets.importTemplate(":clustering")

emptyCheckSw := assets.importSoftware("@platforma-open/milaboratories.clonotype-clustering.software:empty-check")

// Write query function
doQuery := func(wf, args) {
	bundleBuilder := wf.createPBundleBuilder()
	bundleBuilder.ignoreMissingDomains() // to make query work for both bulk and single cell data
	bundleBuilder.addAnchor("main", args.datasetRef)

	// abundance
	bundleBuilder.addSingle({
		axes: [ { anchor: "main", idx: 0 }, { anchor: "main", idx: 1 }],
		annotations: {
				"pl7.app/isAbundance": "true",
				"pl7.app/abundance/normalized": "false",
				"pl7.app/abundance/isPrimary": "true"
			}
		},
		"abundance")

	for ref in args.sequencesRef {
		// pull sequences
		bundleBuilder.addSingle(ref)
	}

	// @TODO: Implement in the future
	// // pull genes
	// for gene in ["V", "J"] {
	// 	bundleBuilder.addSingle({
	// 			axes: [{ anchor: "main", idx: 1 }],
	// 			name: "pl7.app/vdj/geneHit",
	// 			domain: {
	// 				"pl7.app/vdj/reference": gene + "Gene",
	// 				"pl7.app/vdj/scClonotypeChain": "A",
	// 				"pl7.app/vdj/scClonotypeChain/index": "primary"
	// 			}
	// 		},
	// 	 gene + "Gene")
	// }

	// mmseqs2 uses same sequence for centroids, so we use same clonotypeKey as a clusterId
	// and we need to pull corresponding labels from the result pool
	// @TODO: remove this part when this labels are generated in bulk MiXCR workflow
	bundleBuilder.addSingle(
		{
			axes: [{ anchor: "main", idx: 1 }],
			name: "pl7.app/label"
		}, "clonotypeKeyLabels")

	return bundleBuilder.build()
}

wf.prepare(func(args) {

	return {
		columns: doQuery(wf, args)
		}
})

wf.body(func(args) {
	blockId := wf.blockId().getDataAsJson()

	// sort to preserve order of sequences
	sequencesRef := slices.quickSort(args.sequencesRef)

	columns := args.columns
	datasetSpec := columns.getSpec(args.datasetRef)
	abundanceSpec := columns.getSpec("abundance")

	// sType := args.sequenceType == "aminoacid" ? "aa" : "nt"

	// input table
	seqTableBuilder := pframes.tsvFileBuilder()
	seqTableBuilder.setAxisHeader(datasetSpec.axesSpec[1].name, "clonotypeKey")
	for nr, seq in sequencesRef {
		seqTableBuilder.add(columns.getColumn(seq), {header: "sequence_" + string(nr)})
	}
	seqTable := seqTableBuilder.build()

	// Run script to check if input table is emptyAdd commentMore actions
	emptyCheck := exec.builder().
			software(emptyCheckSw).
			addFile("sequences.tsv", seqTable).
			arg("--output").arg(".").
			arg("--input").arg("sequences.tsv").
			arg("--input-separator").arg("\t").
			saveFileContent("isFileEmpty.txt").
			printErrStreamToStdout().
			saveStdoutContent().
			cache(24 * 60 * 60 * 1000).
			run()

	// get check content to be resolved in sub-templateAdd commentMore actions
	emptyOrNot := emptyCheck.getFileContent("isFileEmpty.txt")

	/////////// Run clustering template ///////////
	// Analysis will only run if result from emptyOrNot is "notEmpty"
	clusteringAnalysis := render.create(clusteringTpl, {
		emptyOrNot: emptyOrNot,
		seqTable: seqTable,
		columns: doQuery(wf, args),
		datasetSpec: datasetSpec,
		abundanceSpec: abundanceSpec,
		identity: args.identity,
		similarityType: args.similarityType,
		coverageThreshold: args.coverageThreshold,
		coverageMode: args.coverageMode,
		sequencesRef: sequencesRef,
		blockId: blockId
	})

	// Gather results from clusteringAnalysis template
	clustersPf := clusteringAnalysis.output("clustersPf", 24 * 60 * 60 * 1000)
	msaPf := clusteringAnalysis.output("msaPf", 24 * 60 * 60 * 1000)
	pf := clusteringAnalysis.output("pf", 24 * 60 * 60 * 1000)
	clusterAbundanceSpec := clusteringAnalysis.output("clusterAbundanceSpec", 24 * 60 * 60 * 1000)
	mmseqs := clusteringAnalysis.output("mmseqs", 24 * 60 * 60 * 1000)
	inputState := clusteringAnalysis.output("inputState", 24 * 60 * 60 * 1000)

	return {
		outputs: {
			// for table
			clustersPf: pframes.exportFrame(clustersPf),
			// for MSA
			msaPf: pframes.exportFrame(msaPf),
			// pf for plots
			pf: pframes.exportFrame(pf),
			// specs to outputs for visualization purposes
			clusterAbundanceSpec: clusterAbundanceSpec,

			// save mmseqs2 result in the output to enable deduplication of mmseqs2 run
			// NOTE: mmseqs2 produces different results for same input (different line order)
			mmseqs: mmseqs,
			inputState: inputState
		},
		exports: {
			pf: pf
		}
	}
})

