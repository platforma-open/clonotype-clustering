// "hello world"
wf := import("@platforma-sdk/workflow-tengo:workflow")
exec := import("@platforma-sdk/workflow-tengo:exec")
assets:= import("@platforma-sdk/workflow-tengo:assets")
xsv := import("@platforma-sdk/workflow-tengo:pframes.xsv")
pframes := import("@platforma-sdk/workflow-tengo:pframes")
maps := import("@platforma-sdk/workflow-tengo:maps")
slices := import("@platforma-sdk/workflow-tengo:slices")
render := import("@platforma-sdk/workflow-tengo:render")
clusteringTpl := assets.importTemplate(":clustering")
emptyCheckTpl := assets.importTemplate(":empty-check")
buildResults := assets.importTemplate(":build-results")

// Write query function
doQuery := func(wf, args) {
	bundleBuilder := wf.createPBundleBuilder()
	bundleBuilder.ignoreMissingDomains() // to make query work for both bulk and single cell data
	bundleBuilder.addAnchor("main", args.datasetRef)

	// abundance
	bundleBuilder.addSingle({
		axes: [ { anchor: "main", idx: 0 }, { anchor: "main", idx: 1 }],
		annotations: {
				"pl7.app/isAbundance": "true",
				"pl7.app/abundance/normalized": "false",
				"pl7.app/abundance/isPrimary": "true"
			}
		},
		"abundance")

	for ref in args.sequencesRef {
		// pull sequences
		bundleBuilder.addSingle(ref)
	}

	// @TODO: Implement in the future
	// // pull genes
	// for gene in ["V", "J"] {
	// 	bundleBuilder.addSingle({
	// 			axes: [{ anchor: "main", idx: 1 }],
	// 			name: "pl7.app/vdj/geneHit",
	// 			domain: {
	// 				"pl7.app/vdj/reference": gene + "Gene",
	// 				"pl7.app/vdj/scClonotypeChain": "A",
	// 				"pl7.app/vdj/scClonotypeChain/index": "primary"
	// 			}
	// 		},
	// 	 gene + "Gene")
	// }

	// mmseqs2 uses same sequence for centroids, so we use same clonotypeKey as a clusterId
	// and we need to pull corresponding labels from the result pool
	// @TODO: remove this part when this labels are generated in bulk MiXCR workflow
	bundleBuilder.addMulti(
		{
			axes: [{ anchor: "main", idx: 1 }],
			name: "pl7.app/label"
		}, "clonotypeKeyLabels")

	return bundleBuilder.build()
}

wf.prepare(func(args) {

	return {
		columns: doQuery(wf, args)
		}
})

wf.body(func(args) {
	blockId := wf.blockId().getDataAsJson()

	// sort to preserve order of sequences
	sequencesRef := slices.quickSort(args.sequencesRef)

	columns := args.columns
	datasetSpec := columns.getSpec(args.datasetRef)
	abundanceSpec := columns.getSpec("abundance")

	// sType := args.sequenceType == "aminoacid" ? "aa" : "nt"

	// input table
	seqTableBuilder := pframes.tsvFileBuilder()
	seqTableBuilder.mem("32GiB") // @TODO: set based on the size of the input
	seqTableBuilder.cpu(4) // @TODO: set based on the size of the input
	
	seqTableBuilder.setAxisHeader(datasetSpec.axesSpec[1].name, "clonotypeKey")
	for nr, seq in sequencesRef {
		seqTableBuilder.add(columns.getColumn(seq), {header: "sequence_" + string(nr)})
	}
	seqTable := seqTableBuilder.build()

	// Check if input pcols are empty
	emptyCheckAnalysis := render.create(emptyCheckTpl, {
		seqTable: seqTable
	})
	
	// get check content to be resolved in sub-templateAdd commentMore actions
	emptyOrNot := emptyCheckAnalysis.output("emptyResult")

	/////////// Run clustering template ///////////
	// Analysis will only run if result from emptyOrNot is "notEmpty"
	clusteringAnalysis := render.create(clusteringTpl, {
		emptyOrNot: emptyOrNot,
		seqTable: seqTable,
		columns: doQuery(wf, args),
		datasetSpec: datasetSpec,
		abundanceSpec: abundanceSpec,
		identity: args.identity,
		similarityType: args.similarityType,
		coverageThreshold: args.coverageThreshold,
		coverageMode: args.coverageMode,
		sequencesRef: sequencesRef,
		trimStart: args.trimStart,
		trimEnd: args.trimEnd,
		metaInputs: {
			mem: args.mem,
			cpu: args.cpu
		}
	})

	// Gather raw results from clusteringAnalysis template
	mmseqs := clusteringAnalysis.output("mmseqs")
	mmseqsOutput := clusteringAnalysis.output("mmseqsOutput")
	isEmpty := clusteringAnalysis.output("isEmpty")

	// Build pFrames using the library
	defaultConvMem := "16GiB"
	defaultConvCpu := 1
	trimStart := is_undefined(args.trimStart) ? 0 : args.trimStart
	trimEnd := is_undefined(args.trimEnd) ? 0 : args.trimEnd

	builtResults := render.create(buildResults, {
		emptyOrNot: emptyOrNot,
		abundances: clusteringAnalysis.output("abundances"),
		clusterToSeq: clusteringAnalysis.output("clusterToSeq"),
		cloneToCluster: clusteringAnalysis.output("cloneToCluster"),
		abundancesPerCluster: clusteringAnalysis.output("abundancesPerCluster"),
		distanceToCentroid: clusteringAnalysis.output("distanceToCentroid"),
		clusterRadius: clusteringAnalysis.output("clusterRadius"),
		clusterToSeqTop: clusteringAnalysis.output("clusterToSeqTop"),
		clusterRadiusTop: clusteringAnalysis.output("clusterRadiusTop"),
		abundancesTop: clusteringAnalysis.output("abundancesTop"),
		trimmedSequences: clusteringAnalysis.output("trimmedSequences"),
		datasetSpec: datasetSpec,
		abundanceSpec: abundanceSpec,
		columns: doQuery(wf, args),
		sequencesRef: sequencesRef,
		trimStart: trimStart,
		trimEnd: trimEnd,
		identity: args.identity,
		similarityType: args.similarityType,
		coverageThreshold: args.coverageThreshold,
		defaultConvMem: defaultConvMem,
		defaultConvCpu: defaultConvCpu,
		metaInputs: {
			blockId: blockId
		}
	})

	clustersPf := builtResults.output("clustersPf")
	bubblePlotPf := builtResults.output("bubblePlotPf")
	msaPf := builtResults.output("msaPf")
	pf := builtResults.output("pf")
	clusterAbundanceSpec := builtResults.output("clusterAbundanceSpec")

	return {
		outputs: {
			// for table
			clustersPf: pframes.exportFrame(clustersPf),
			// for bubble plot
			bubblePlotPf: pframes.exportFrame(bubblePlotPf),
			// for MSA
			msaPf: pframes.exportFrame(msaPf),
			// pf for plots
			pf: pframes.exportFrame(pf),
			// specs to outputs for visualization purposes
			clusterAbundanceSpec: clusterAbundanceSpec,

			// save mmseqs2 result in the output to enable deduplication of mmseqs2 run
			// NOTE: mmseqs2 produces different results for same input (different line order)
			mmseqs: mmseqs,
			mmseqsOutput: mmseqsOutput,
			abundances: clusteringAnalysis.output("abundances"),
			clusterToSeq: clusteringAnalysis.output("clusterToSeq"),
			cloneToCluster: clusteringAnalysis.output("cloneToCluster"),
			abundancesPerCluster: clusteringAnalysis.output("abundancesPerCluster"),
			distanceToCentroid: clusteringAnalysis.output("distanceToCentroid"),
			clusterRadius: clusteringAnalysis.output("clusterRadius"),
			clusterToSeqTop: clusteringAnalysis.output("clusterToSeqTop"),
			clusterRadiusTop: clusteringAnalysis.output("clusterRadiusTop"),
			abundancesTop: clusteringAnalysis.output("abundancesTop"),
			trimmedSequences: clusteringAnalysis.output("trimmedSequences"),
			isEmpty: isEmpty
		},
		exports: {
			pf: pf
		}
	}
})

