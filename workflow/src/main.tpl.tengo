// "hello world"
wf := import("@platforma-sdk/workflow-tengo:workflow")
exec := import("@platforma-sdk/workflow-tengo:exec")
assets:= import("@platforma-sdk/workflow-tengo:assets")
xsv := import("@platforma-sdk/workflow-tengo:pframes.xsv")
text := import("text")
pframes := import("@platforma-sdk/workflow-tengo:pframes")
pSpec := import("@platforma-sdk/workflow-tengo:pframes.spec")

pfClustersConv := import(":pf-clusters-conv")
pfUMAPConv := import(":pf-umap-conv")
pfTSNEConv := import(":pf-tsne-conv")

wf.prepare(func(args) {

	clonotypingRunId := args.clonotypingRunId
	dataType := args.dataType
	chain := args.chain

	// get chain value in same format as domain (only in bulk) 
	formattedChain := ""
	// define both chains by default in singleCell
	if dataType == "bulk" {
		formattedChain = text.replace(chain, " ", "", -1)
	}
	
	// Get Pcolumns matching the specified values
	query := func(label) {
		domain := {
						"pl7.app/vdj/clonotypingRunId": clonotypingRunId,
						"pl7.app/alphabet": "aminoacid",
						"pl7.app/vdj/feature": "CDR3"
					}
		if dataType == "bulk" {
			domain["pl7.app/vdj/chain"] = formattedChain
		} else if dataType == "singleCell" {
			domain["pl7.app/vdj/scClonotypeChain/index"] = "primary"
		}

		r := {
			type: "And",
			operands:  [
				{
					type: "Annotation",
					annotation: "pl7.app/label",
					value: label
				},
				{
					type: "Domain",
					domain: domain,
					domainExactMatch: false
				}
			]
		}

		return r
	}
	

	ops := {
		single: true
	}

	if dataType == "singleCell" {
		// ll := import("@platforma-sdk/workflow-tengo:ll")
		// maps := import("@platforma-sdk/workflow-tengo:maps")
		// ll.panic("%v", chain)
		outputs := {}
		if chain == "Both chains" {
				outputs["selectedChains1"] = wf.query(query("Heavy CDR3 aa Primary"), ops) 
				outputs["selectedChains2"] = wf.query(query("Light CDR3 aa Primary"), ops)
		} else {
			outputs["selectedChains"] = wf.query(query(chain), ops) 
		}
		return  outputs

	} else if dataType == "bulk" {
		return  { 
			selectedChains: wf.query(query("CDR3 aa"), ops)
		}
	}
})

wf.body(func(args) {
	selectedChains := args.selectedChains
	clonotypingRunId := args.clonotypingRunId
	chain := args.chain
	dataType := args.dataType
	selectedChainsSpec := selectedChains.spec

	if dataType == "bulk" {
		selectedChains = [selectedChains]
	} else {
		if chain == "Both chains" {
			selectedChains = [args.selectedChains1, args.selectedChains2]
		} else {
			selectedChains = [args.selectedChains]
		}
		
	}
	

	
	csv := xsv.exportFrame(selectedChains, "csv", {})


	metric := "levenshtein"
	resolution := 1.0

	clonotypeClustering := exec.builder().
		software(assets.importSoftware("@platforma-open/milaboratories.clonotype-clustering.software:clonotype-clustering")).
		addFile("input.csv", csv).
		arg("--input").arg("input.csv").
		arg("--output_clusters").arg("clusters.csv").
		arg("--output_umap").arg("umap.csv").
		arg("--output_tsne").arg("tsne.csv").
		arg("--metric").arg(metric).
		arg("--resolution").arg(string(resolution)).
		saveFile("clusters.csv").
		saveFile("umap.csv").
		saveFile("tsne.csv").
		printErrStreamToStdout().
		saveStdoutContent().
		cache(24 * 60 * 60 * 1000).
		run()

	testCmd := exec.builder().
		cmd("sleep 100").
		addFile("input.csv", csv).
		saveFile("input.csv").
		run()

	result := testCmd.getFile("result.tsv")

	clustersImportParams := pfClustersConv.getColumns(selectedChainsSpec, resolution, metric)
	clustersPf := xsv.importFile(clonotypeClustering.getFile("clusters.csv"), "csv", clustersImportParams)

	UMAPImportParams := pfUMAPConv.getColumns(selectedChainsSpec, metric)
	UMAPPf := xsv.importFile(clonotypeClustering.getFile("umap.csv"), "csv", UMAPImportParams)

	// TSNEImportParams := pfTSNEConv.getColumns(selectedChainsSpec, metric)
	// TSNEPf := xsv.importFile(clonotypeClustering.getFile("tsne.csv"), "csv", TSNEImportParams)

	return {
		outputs: {
			clustersPf: clustersPf,
			UMAPPf: UMAPPf
			// TSNEPf: TSNEPf
		},
		exports: {}
	}
})

