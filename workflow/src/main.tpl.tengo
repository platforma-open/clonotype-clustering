// "hello world"
wf := import("@platforma-sdk/workflow-tengo:workflow")
exec := import("@platforma-sdk/workflow-tengo:exec")
assets:= import("@platforma-sdk/workflow-tengo:assets")
xsv := import("@platforma-sdk/workflow-tengo:pframes.xsv")
pframes := import("@platforma-sdk/workflow-tengo:pframes")
maps := import("@platforma-sdk/workflow-tengo:maps")
pSpec := import("@platforma-sdk/workflow-tengo:pframes.spec")


prepareFastaSw := assets.importSoftware("@platforma-open/milaboratories.clonotype-clustering.software:prepare-fasta")
processResultsSw := assets.importSoftware("@platforma-open/milaboratories.clonotype-clustering.software:process-results")

setVisibility := func(spec, visibility) {
	return maps.deepMerge(spec, {
		annotations: {
			"pl7.app/table/visibility": visibility ? "default" : "optional"
		}
	})
}

wf.prepare(func(args) {
	bundleBuilder := wf.createPBundleBuilder()
	bundleBuilder.ignoreMissingDomains() // to make query work for both bulk and single cell data
	bundleBuilder.addAnchor("main", args.aaSeqCDR3Ref) 
	bundleBuilder.addSingle(args.abundanceRef)
	for gene in ["V", "J"] {
		bundleBuilder.addSingle({
				axes: [{ anchor: "main", idx: 0 }],
				name: "pl7.app/vdj/geneHit",
				domain: {
					"pl7.app/vdj/reference": gene + "Gene",
					"pl7.app/vdj/scClonotypeChain": { anchor: "main" },
					"pl7.app/vdj/scClonotypeChain/index": { anchor: "main" }
				}
			},
		 gene + "Gene")
	}

	if args.clusterBothChains {
		bundleBuilder.addSingle({
				axes: [{ anchor: "main", idx: 0 }],
				name: "pl7.app/vdj/sequence",
				domain: {
					"pl7.app/vdj/feature": "CDR3",
					"pl7.app/alphabet": "aminoacid",
					"pl7.app/vdj/scClonotypeChain": "B",
					"pl7.app/vdj/scClonotypeChain/index": { anchor: "main" }
				}
			}, "secondChain")
	}

	// mmseqs2 uses same sequence for centroids, so we use same clonotypeKey as a clusterId
	// and we need to pull corresponding labels from the result pool
	bundleBuilder.addSingle(
		{
			axes: [{ anchor: "main", idx: 0 }],
			name: "pl7.app/label"
		}, "clonotypeKeyLabels") 
	
	return {
		columns: bundleBuilder.build()
	}
})

wf.body(func(args) {
	blockId := wf.blockId().getDataAsJson()
	
	columns := args.columns

	aaSeqCDR3Spec := columns.getSpec(args.aaSeqCDR3Ref)
	abundanceSpec := columns.getSpec(args.abundanceRef)
	isSingleCell := aaSeqCDR3Spec.axesSpec[0].name == "pl7.app/vdj/scClonotypeKey"
	
	/***** Step 1: do clustering on the clonotype level *****/

	// input table
	seqTable := columns.xsvTableBuilder()
	seqTable.setAxisHeader(aaSeqCDR3Spec.axesSpec[0].name, "clonotypeKey")
	seqTable.add(args.aaSeqCDR3Ref, {header: "aaCDR3"})
	if isSingleCell && args.clusterBothChains {
		seqTable.add("secondChain", {header: "aaCDR3_second"})
	}
	seqTable = seqTable.build("tsv")

	// prepare fasta file
	fasta := exec.builder().
		software(prepareFastaSw).
		addFile("input.tsv", seqTable).
		saveFile("output.fasta").
		run()

	// run mmseqs2
	mmseqs := exec.builder().
		cmd("mmseqs").
		arg("easy-cluster").
		arg("input.fasta").
		arg("result").
		arg("tmp").
		arg("--min-seq-id").arg(string(args.identity)).
		arg("-c").arg(string(args.identity)).
		arg("--cov-mode").arg("1").
		addFile("input.fasta", fasta.getFile("output.fasta")).
		saveFile("result_cluster.tsv").
		run()

	clusters := mmseqs.getFile("result_cluster.tsv")


	/******* Step 2: aggregate all data and generate results *******/
	cloneTable := columns.xsvTableBuilder()
	cloneTable.add(args.abundanceRef, {header: "abundance"})
	cloneTable.add(args.aaSeqCDR3Ref, {header: "aaCDR3"})
	if isSingleCell && args.clusterBothChains {
		cloneTable.add("secondChain", {header: "aaCDR3_second"})
	}
	cloneTable.add("clonotypeKeyLabels", {header: "clonotypeKeyLabel"})
	cloneTable.add("VGene", {header: "VGene"})
	cloneTable.add("JGene", {header: "JGene"})
	cloneTable.setAxisHeader(abundanceSpec.axesSpec[0].name, "sampleId")
	cloneTable.setAxisHeader(abundanceSpec.axesSpec[1].name, "clonotypeKey")
	cloneTable = cloneTable.build("tsv")


	result := exec.builder().
		software(processResultsSw).
		addFile("clusters.tsv", clusters).
		addFile("cloneTable.tsv", cloneTable).
		saveFile("abundances.tsv").
		saveFile("cluster-to-seq.tsv").
		saveFile("clone-to-cluster.tsv").
		run()


	abundances := result.getFile("abundances.tsv")
	clusterIdAxisSpec := {
		name: "pl7.app/vdj/clusterId",
		type: "String",
		domain: maps.deepMerge(aaSeqCDR3Spec.axesSpec[0].domain, 
		{
			"pl7.app/vdj/clustering/algorithm": "mmseqs2",
			"pl7.app/vdj/clustering/blockId": blockId
			// @TODO: add clustering parameters here
		}),
		annotations: {
			"pl7.app/label": "Cluster Id",
			"pl7.app/table/visibility": "default"
		}
	}
	
	abundancesPf := xsv.importFile(abundances, "tsv", {
		axes: [{
			column: "sampleId",
			spec: abundanceSpec.axesSpec[0]
		}, {
			column: "clusterId",
			spec: clusterIdAxisSpec
		}],
		columns: [{
			column: "abundance",
			spec:  {
				name: abundanceSpec.name,
				valueType: abundanceSpec.valueType,
				domain: abundanceSpec.domain,
				annotations: abundanceSpec.annotations
			}
		}]
	}, {splitDataAndSpec: true})

	cloneToCluster := result.getFile("clone-to-cluster.tsv")
	cloneToClusterPf := xsv.importFile(cloneToCluster, "tsv", {
		axes: [{
			column: "clonotypeKey",
			spec: aaSeqCDR3Spec.axesSpec[0]
		}],
		columns: [{
			column: "clusterId",
			spec: {
				name: "pl7.app/vdj/clusterId",
				valueType: "String",
				domain: clusterIdAxisSpec.domain,
				annotations: clusterIdAxisSpec.annotations
			}
		}]
	}, {splitDataAndSpec: true})

	cloneToClusterLinkPf := xsv.importFile(cloneToCluster, "tsv", {
		axes: [{
			column: "clonotypeKey",
			spec: aaSeqCDR3Spec.axesSpec[0]
		}, {
			column: "clusterId",
			spec: clusterIdAxisSpec
		}],
		columns: [{
			column: "link",
			spec: {
				name: "pl7.app/vdj/link",
				valueType: "Int",
				annotations: {
					"pl7.app/isLinkerColumn": "true"
				}
			}
		}]
	}, {splitDataAndSpec: true})
	
	clusterToSeq := result.getFile("cluster-to-seq.tsv")

	seqColumns := [{
		column: "aaCDR3",
		spec: setVisibility({
			name: aaSeqCDR3Spec.name,
			valueType: aaSeqCDR3Spec.valueType,
			domain: aaSeqCDR3Spec.domain,
			annotations: aaSeqCDR3Spec.annotations
		}, true)
	},
	{
		column: "size",
		spec: {
			name: "pl7.app/vdj/clustering/clusterSize",
			valueType: "Int",
			annotations: {
				"pl7.app/label": "Cluster Size"
			}
		}
	}, {
		column: "clonotypeKeyLabel",
		spec: {
			name: "pl7.app/label",
			valueType: "String",
			annotations: {
				"pl7.app/label": "Cluster Label"
			}
		}
	}]

	if isSingleCell && args.clusterBothChains {
		secondChainSpec := columns.getSpec("secondChain")
		seqColumns = append(seqColumns, {
			column: "aaCDR3_second",
			spec: setVisibility({
				name: secondChainSpec.name,
				valueType: secondChainSpec.valueType,
				domain: secondChainSpec.domain,
				annotations: secondChainSpec.annotations
			}, true)
		})
	}
	clusterToSeqPf := xsv.importFile(clusterToSeq, "tsv", {
		axes: [{
			column: "clusterId",
			spec: clusterIdAxisSpec
		}],
		columns: seqColumns
	}, {splitDataAndSpec: true})
		

	trace := pSpec.makeTrace(abundanceSpec,
		{
			type: "milaboratories.clonotype-clustering",
		 	importance: 30,
		 	label: "Clonotype clusters"
		})
		
	opf := pframes.pFrameBuilder()
	for k, v in clusterToSeqPf {
		opf.add(k, trace.inject(v.spec), v.data)
	}
	opf = opf.build()

	epf := pframes.pFrameBuilder() 
	for pf in [abundancesPf, cloneToClusterPf, cloneToClusterLinkPf, clusterToSeqPf] {
		i := 0
		for k, v in pf {
			epf.add(k + string(i), trace.inject(v.spec), v.data)
			i++
		}
	}
	epf = epf.build()

	return {
		outputs: {
			clustersPf: pframes.exportFrame(opf),
			// for plots; also add specs to outputs for visualization purposes
			pf: pframes.exportFrame(epf),
			clusterAbundanceSpec: abundancesPf["abundance"].spec
		},
		exports: {
			pf: epf
		}
	}
})

