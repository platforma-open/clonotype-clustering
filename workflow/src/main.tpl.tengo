// "hello world"
wf := import("@platforma-sdk/workflow-tengo:workflow")
exec := import("@platforma-sdk/workflow-tengo:exec")
assets:= import("@platforma-sdk/workflow-tengo:assets")
xsv := import("@platforma-sdk/workflow-tengo:pframes.xsv")
text := import("text")
pframes := import("@platforma-sdk/workflow-tengo:pframes")
pSpec := import("@platforma-sdk/workflow-tengo:pframes.spec")
ll := import("@platforma-sdk/workflow-tengo:ll")

pfClustersConv := import(":pf-clusters-conv")
pfUmapConv := import(":pf-umap-conv")
pfTsneConv := import(":pf-tsne-conv")
pfMetricsConv := import(":pf-metrics-conv")
json := import("json")


wf.prepare(func(args) {
	bundleBuilder := wf.createPBundleBuilder()
	bundleBuilder.ignoreMissingDomains() // to make query work for both bulk and single cell data
	bundleBuilder.addAnchor("main", args.aaSeqCDR3Ref) 
	if args.clusterBothChains {
		bundleBuilder.addSingle({
				axes: [{ anchor: "main", idx: 0 }],
				name: "pl7.app/vdj/sequence",
				domain: {
					"pl7.app/vdj/feature": "CDR3",
					"pl7.app/alphabet": "aminoacid",
					"pl7.app/vdj/scClonotypeChain": "B",
					"pl7.app/vdj/scClonotypeChain/index": { anchor: "main" }
				}
			},
		 "secondChain")
	}
	
	return {
		columns: bundleBuilder.build()
	}
})

wf.body(func(args) {
	resolution := args.resolution
	metric := args.metric

	columns := args.columns

	aaSeqCDR3Spec := columns.getSpec(args.aaSeqCDR3Ref)
	isSingleCell := aaSeqCDR3Spec.axesSpec[0].name == "pl7.app/vdj/scClonotypeKey"
	
	table := columns.xsvTableBuilder()
	table.setAxisHeader(aaSeqCDR3Spec.axesSpec[0].name, "clonotype_id")
	table.add(args.aaSeqCDR3Ref, {header: "aaCDR3"})
	if isSingleCell && args.clusterBothChains {
		table.add("secondChain", {header: "aaCDR3_second"})
	}
	csv := table.build("csv")

	clonotypeClustering := exec.builder().
		software(assets.importSoftware("@platforma-open/milaboratories.clonotype-clustering.software:clonotype-clustering")).
		addFile("input.csv", csv).
		arg("--input").arg("input.csv").
		arg("--output_clusters").arg("clusters.csv").
		arg("--output_umap").arg("umap.csv").
		arg("--output_tsne").arg("tsne.csv").
		arg("--metric").arg(metric).
		arg("--resolution").arg(string(resolution)).
		saveFile("clusters.csv").
		saveFile("umap.csv").
		// saveFile("tsne.csv").
		saveFile("cluster_summary_metrics.csv").
		printErrStreamToStdout().
		saveStdoutContent().
		cache(24 * 60 * 60 * 1000).
		run()

	clustersImportParams := pfClustersConv.getColumns(aaSeqCDR3Spec, resolution, metric)
	clustersPf := xsv.importFile(clonotypeClustering.getFile("clusters.csv"), "csv", clustersImportParams)

	umapPf := xsv.importFile(
		clonotypeClustering.getFile("umap.csv"), 
		"csv", 
		pfUmapConv.getColumns(aaSeqCDR3Spec, metric))

	// tsnePf := xsv.importFile(
	// 	clonotypeClustering.getFile("tsne.csv"),
	// 	"csv",
	// 	pfTsneConv.getColumns(combinedSpec, metric)
	// )

	metricsImportParams := pfMetricsConv.getColumns(metric)
	metricsPf := xsv.importFile(clonotypeClustering.getFile("cluster_summary_metrics.csv"), "csv", metricsImportParams)

	return {
		outputs: {
			clustersPf: pframes.exportFrame(clustersPf),
			umapPf: pframes.exportFrame(umapPf),
			metricsPf: pframes.exportFrame(metricsPf)
		},
		exports: {
			clustersPf: {
				spec: clustersPf["clonotypeCluster.spec"],
				data: clustersPf["clonotypeCluster.data"]
			}
		}
	}
})

