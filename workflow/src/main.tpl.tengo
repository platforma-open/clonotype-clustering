// "hello world"
wf := import("@platforma-sdk/workflow-tengo:workflow")
ll := import("@platforma-sdk/workflow-tengo:ll")
exec := import("@platforma-sdk/workflow-tengo:exec")
assets:= import("@platforma-sdk/workflow-tengo:assets")
xsv := import("@platforma-sdk/workflow-tengo:pframes.xsv")
pframes := import("@platforma-sdk/workflow-tengo:pframes")
maps := import("@platforma-sdk/workflow-tengo:maps")
pSpec := import("@platforma-sdk/workflow-tengo:pframes.spec") 
text := import("text")
slices := import("@platforma-sdk/workflow-tengo:slices")
json := import("json")


prepareFastaSw := assets.importSoftware("@platforma-open/milaboratories.clonotype-clustering.software:prepare-fasta")
processResultsSw := assets.importSoftware("@platforma-open/milaboratories.clonotype-clustering.software:process-results")
mmseqsSw := assets.importSoftware("@platforma-open/soedinglab.software-mmseqs2:mmseqs2")

setTableProps := func(spec, label, visibility, orderPriority) {
	return maps.deepMerge(spec, {
		annotations: {
			"pl7.app/label": label,
			"pl7.app/table/visibility": visibility ? "default" : "optional",
			"pl7.app/table/orderPriority": orderPriority
		}
	})
}

wf.prepare(func(args) {
	bundleBuilder := wf.createPBundleBuilder()
	bundleBuilder.ignoreMissingDomains() // to make query work for both bulk and single cell data
	bundleBuilder.addAnchor("main", args.datasetRef) 
	
	// abundance
	bundleBuilder.addSingle({
		axes: [ { anchor: "main", idx: 0 }, { anchor: "main", idx: 1 }],
		annotations: {
				"pl7.app/isAbundance": "true",
				"pl7.app/abundance/normalized": "false",
				"pl7.app/abundance/isPrimary": "true"
			}
		},
		"abundance")

	for nr, ref in args.sequencesRef {
		// pull sequences; for single cell data, we pull both chains
		bundleBuilder.addMulti(ref, "sequences" + string(nr), {
			overrides: {
				domain: {
					// to pull both "A" and "B" chains in single cell data; not used for bulk data
					"pl7.app/vdj/scClonotypeChain": undefined
				}
			}
		})
	}
	
	// @TODO: Implement in the future
	// // pull genes
	// for gene in ["V", "J"] {
	// 	bundleBuilder.addSingle({
	// 			axes: [{ anchor: "main", idx: 1 }],
	// 			name: "pl7.app/vdj/geneHit",
	// 			domain: {
	// 				"pl7.app/vdj/reference": gene + "Gene",
	// 				"pl7.app/vdj/scClonotypeChain": "A",
	// 				"pl7.app/vdj/scClonotypeChain/index": "primary"
	// 			}
	// 		},
	// 	 gene + "Gene")
	// }

	// mmseqs2 uses same sequence for centroids, so we use same clonotypeKey as a clusterId
	// and we need to pull corresponding labels from the result pool
	// @TODO: remove this part when this labels are generated in bulk MiXCR workflow
	bundleBuilder.addSingle(
		{
			axes: [{ anchor: "main", idx: 1 }],
			name: "pl7.app/label"
		}, "clonotypeKeyLabels") 
	
	return {
		columns: bundleBuilder.build()	
		}
})

wf.body(func(args) {
	blockId := wf.blockId().getDataAsJson()
	
	columns := args.columns
	datasetSpec := columns.getSpec(args.datasetRef)
	abundanceSpec := columns.getSpec("abundance")
	// sType := args.sequenceType == "aminoacid" ? "aa" : "nt"

	// check sequence columns
	isSingleCell := datasetSpec.axesSpec[1].name == "pl7.app/vdj/scClonotypeKey"
	for nr, ref in args.sequencesRef {
		sequences := columns.getColumns("sequences" + string(nr))
		if isSingleCell && len(sequences) < 2 {
			ll.panic("expected at least two sequence columns for single cell data")
		} else if isSingleCell == false && (len(sequences) == 0 || len(sequences) > 2) {
			ll.panic("expected exactly one sequence column for bulk data, got ", sequences)
		}
	}

	// Get sorted list of Pcolumn labels
	sequencePrimaryLabels := []
	allFeatures := []
	sequenceSecondaryLabels := []
	for nr, ref in args.sequencesRef {
		sequences := columns.getColumns("sequences" + string(nr))
		// In single cell we use main chain for ordering (A chain)
		if isSingleCell {
			if sequences[0].spec.domain["pl7.app/vdj/scClonotypeChain"] == "A" {
				sequencePrimaryLabels = append(sequencePrimaryLabels, sequences[0].spec.annotations["pl7.app/label"])
				allFeatures = append(allFeatures, sequences[0].spec.domain["pl7.app/vdj/feature"])
			} else {
				sequencePrimaryLabels = append(sequencePrimaryLabels, sequences[1].spec.annotations["pl7.app/label"])
				allFeatures = append(allFeatures, sequences[1].spec.domain["pl7.app/vdj/feature"])
			}
		} else {
			sequencePrimaryLabels = append(sequencePrimaryLabels, sequences[0].spec.annotations["pl7.app/label"])
			allFeatures = append(allFeatures, sequences[0].spec.domain["pl7.app/vdj/feature"])
		}
		
	}
	sequencePrimaryLabels = slices.quickSort(sequencePrimaryLabels)
	allFeatures = slices.quickSort(allFeatures)

	// primary chain sequence column or just sequence column for bulk data
	sequencePrimary := []
	// secondary chain sequence column (for sc data)
	sequenceSecondary := []
	// Iterate over ordered sequence labels to include sequences always in same order
	for slabel in sequencePrimaryLabels {
		for nr, ref in args.sequencesRef {
			sequences := columns.getColumns("sequences" + string(nr))
			if isSingleCell {
				// since we only stored A chain by looking for presence we also now the order
				if sequences[0].spec.annotations["pl7.app/label"] == slabel &&
					sequences[0].spec.domain["pl7.app/vdj/scClonotypeChain"] == "A" {
						sequencePrimary = sequencePrimary + [sequences[0]]
						sequenceSecondary = sequenceSecondary + [sequences[1]]
						sequenceSecondaryLabels = append(sequenceSecondaryLabels, sequences[1].spec.annotations["pl7.app/label"])
				} else if sequences[1].spec.annotations["pl7.app/label"] == slabel &&
					sequences[1].spec.domain["pl7.app/vdj/scClonotypeChain"] == "A" {
						sequencePrimary = sequencePrimary + [sequences[1]]
						sequenceSecondary = sequenceSecondary + [sequences[0]]
						sequenceSecondaryLabels = append(sequenceSecondaryLabels, sequences[0].spec.annotations["pl7.app/label"])
				}
			} else {
				if sequences[0].spec.annotations["pl7.app/label"] == slabel {
					sequencePrimary = sequencePrimary + [sequences[0]]
				}
			}	
		}
	}
	
	/***** Step 1: do clustering on the clonotype level *****/

	// input table
	seqTable := columns.xsvTableBuilder()
	seqTable.setAxisHeader(datasetSpec.axesSpec[1].name, "clonotypeKey")
	
	for nseq, seq in sequencePrimary {
		seqTable.add(seq.key, {header: "sequence_" + string(nseq)})
		if isSingleCell && args.clusterBothChains {
			seqTable.add(sequenceSecondary[nseq].key, {header: "sequence_second_" + string(nseq)})
		}
	}
	
	seqTable = seqTable.build("tsv")

	// prepare fasta file
	fasta := exec.builder().
		software(prepareFastaSw).
		addFile("input.tsv", seqTable).
		saveFile("output.fasta").
		run()

	// run mmseqs2
	// NOTE: mmseqs2 produces different results for same input (different line order),
	// so we save the result in the output to prevent CID conflict by deduplication
	mmseqs := exec.builder().
		software(mmseqsSw).
		dontSaveStdoutOrStderr(). // important to avoid CID conflict problems coming from different stdout output on same datasets
		arg("easy-cluster").
		arg("input.fasta").
		arg("result").
		arg("tmp").
		arg("--min-seq-id").arg(string(args.identity)).
		arg("-c").arg(string(args.identity)).
		arg("--cov-mode").arg("1").
		addFile("input.fasta", fasta.getFile("output.fasta")).
		saveFile("result_cluster.tsv").
		run()

	clusters := mmseqs.getFile("result_cluster.tsv")


	/******* Step 2: aggregate all data and generate results *******/
	cloneTable := columns.xsvTableBuilder()
	cloneTable.add("abundance", {header: "abundance"})
	
	for nseq, seq in sequencePrimary {
		cloneTable.add(seq.key, {header: "sequence_" + string(nseq)})
		if isSingleCell && args.clusterBothChains {
			cloneTable.add(sequenceSecondary[nseq].key, {header: "sequence_second_" + string(nseq)})
		}
	}
	
	cloneTable.add("clonotypeKeyLabels", {header: "clonotypeKeyLabel"})
	// cloneTable.add("VGene", {header: "VGene"})
	// cloneTable.add("JGene", {header: "JGene"})
	cloneTable.setAxisHeader(abundanceSpec.axesSpec[0].name, "sampleId")
	cloneTable.setAxisHeader(abundanceSpec.axesSpec[1].name, "clonotypeKey")
	cloneTable = cloneTable.build("tsv")


	result := exec.builder().
		software(processResultsSw).
		addFile("clusters.tsv", clusters).
		addFile("cloneTable.tsv", cloneTable).
		saveFile("abundances.tsv").
		saveFile("cluster-to-seq.tsv").
		saveFile("clone-to-cluster.tsv").
		saveFile("abundances-per-cluster.tsv"). // cluster to summed abundances
		run()


	abundances := result.getFile("abundances.tsv")
	clusterIdAxisSpec := {
		name: "pl7.app/vdj/clusterId",
		type: "String",
		domain: maps.deepMerge(datasetSpec.axesSpec[1].domain, 
		{
			"pl7.app/vdj/clustering/algorithm": "mmseqs2",
			"pl7.app/vdj/clustering/blockId": blockId
			// @TODO: add clustering parameters here
		}),
		annotations: {
			"pl7.app/label": "Cluster Id",
			"pl7.app/table/visibility": "default",
			"pl7.app/table/orderPriority": "990000"
		}
	}

	ac := {
		name: abundanceSpec.name,
		valueType: abundanceSpec.valueType,
		domain: abundanceSpec.domain,
		annotations: abundanceSpec.annotations
	}

	abundanceLabel := abundanceSpec.annotations["pl7.app/label"]

	abundancesPf := xsv.importFile(abundances, "tsv", {
		axes: [{
			column: "sampleId",
			spec: abundanceSpec.axesSpec[0]
		}, {
			column: "clusterId",
			spec: clusterIdAxisSpec
		}],
		columns: [{
			column: "abundance",
			spec: setTableProps(ac, abundanceLabel + " in cluster", false, undefined)
		},
		{
			column: "abundance_normalized",
			spec: setTableProps(maps.deepMerge(ac, {
				valueType: "Float",
				annotations: {
					"pl7.app/abundance/normalized": "true"
				}
			}), text.re_replace("Number", abundanceLabel, "Fraction") + " in cluster", false, undefined)
		}]
	}, {splitDataAndSpec: true})


	abundancesPerCluster := result.getFile("abundances-per-cluster.tsv")

	abundancesPerClusterPf := xsv.importFile(abundancesPerCluster, "tsv", {
		axes: [{
			column: "clusterId",
			spec: clusterIdAxisSpec
		}],
		columns: [{
			column: "abundance_per_cluster",
			spec: setTableProps(ac, "Total " + abundanceLabel + " in cluster", false, undefined)
		}]
	}, {splitDataAndSpec: true})

	cloneToCluster := result.getFile("clone-to-cluster.tsv")
	cloneToClusterPf := xsv.importFile(cloneToCluster, "tsv", {
		axes: [{
			column: "clonotypeKey",
			spec: datasetSpec.axesSpec[1]
		}],
		columns: [{
			column: "clusterLabel",
			spec: setTableProps({
				name: "pl7.app/vdj/clusterId",
				valueType: "String",
				domain: clusterIdAxisSpec.domain,
				annotations: clusterIdAxisSpec.annotations
			}, "Cluster Id", false, undefined)
		}]
	}, {splitDataAndSpec: true})

	cloneToClusterLinkPf := xsv.importFile(cloneToCluster, "tsv", {
		axes: [{
			column: "clonotypeKey",
			spec: datasetSpec.axesSpec[1]
		}, {
			column: "clusterId",
			spec: clusterIdAxisSpec
		}],
		columns: [{
			column: "link",
			spec: setTableProps({
				name: "pl7.app/vdj/link",
				valueType: "Int",
				annotations: {
					"pl7.app/isLinkerColumn": "true"
				}
			}, "Clone to cluster link", false, undefined)
		}]
	}, {splitDataAndSpec: true})
	
	clusterToSeq := result.getFile("cluster-to-seq.tsv")

	seqColumns := [
	{
		column: "size",
		spec: {
			name: "pl7.app/vdj/clustering/clusterSize",
			valueType: "Int",
			annotations: {
				"pl7.app/label": "Cluster Size"
			}
		}
	}, {
		column: "clusterLabel",
		spec: {
			name: "pl7.app/label",
			valueType: "String",
			annotations: {
				"pl7.app/label": "Cluster Id"
			}
		}
	}]

	// Add sequence columns
	for nseq, seq in sequencePrimary {
		spec := copy(seq.spec)
		spec.annotations["pl7.app/label"] = "Centroid " + spec.annotations["pl7.app/label"]
		seqColumns = append(seqColumns, {
			column: "sequence_" + string(nseq),
			spec: setTableProps({
				name: spec.name,
				valueType: spec.valueType,
				domain: spec.domain,
				annotations: spec.annotations
			}, spec.annotations["pl7.app/label"], true, "10")
		})
	}
	

	if isSingleCell && args.clusterBothChains {
		for nseq, seq in sequenceSecondary {
			spec := copy(seq.spec)
			spec.annotations["pl7.app/label"] = "Centroid " + spec.annotations["pl7.app/label"]
			seqColumns = append(seqColumns, {
				column: "sequence_second_" + string(nseq),
				spec: setTableProps({
					name: spec.name,
					valueType: spec.valueType,
					domain: spec.domain,
					annotations: spec.annotations
				}, spec.annotations["pl7.app/label"], true, "20")
			})
		}
	}
	clusterToSeqPf := xsv.importFile(clusterToSeq, "tsv", {
		axes: [{
			column: "clusterId",
			spec: clusterIdAxisSpec
		}],
		columns: seqColumns
	}, {splitDataAndSpec: true})
		
	// building outputs & exports
	trace := pSpec.makeTrace(abundanceSpec,
		{
			type: "milaboratories.clonotype-clustering",
		 	importance: 30,
		 	label: "Clonotype clusters"
		})

	opf := pframes.pFrameBuilder()
	for k, v in clusterToSeqPf {
		if k == "clusterLabel" {
			 // avoid putting label into the outputs as it will be already in exports; 
			 // in future should be safe to add once PlAgDataTable bug is fixed
			continue
		}
		opf.add(k, trace.inject(v.spec), v.data)
	}
	opf = opf.build()

	epf := pframes.pFrameBuilder() 
	i := 0
	for pf in [abundancesPf, cloneToClusterPf, cloneToClusterLinkPf, clusterToSeqPf, abundancesPerClusterPf] {
		for k, v in pf {
			epf.add(k + string(i), trace.inject(v.spec), v.data) // label, specs, data
			i = i + 1
		}
	}
	epf = epf.build()

	clusterAbundanceSpec := trace.inject(abundancesPf["abundance"].spec)

	return {
		outputs: {
			// for table
			clustersPf: pframes.exportFrame(opf),
			// pf for plots
			pf: pframes.exportFrame(epf),
			// specs to outputs for visualization purposes
			clusterAbundanceSpec: clusterAbundanceSpec,
			
			// save mmseqs2 result in the output to enable deduplication of mmseqs2 run
			// NOTE: mmseqs2 produces different results for same input (different line order)
			mmseqs: clusters
		},
		exports: {
			pf: epf
		}
	}
})

