self := import("@platforma-sdk/workflow-tengo:tpl")
ll := import("@platforma-sdk/workflow-tengo:ll")
exec := import("@platforma-sdk/workflow-tengo:exec")
assets:= import("@platforma-sdk/workflow-tengo:assets")
xsv := import("@platforma-sdk/workflow-tengo:pframes.xsv")
pframes := import("@platforma-sdk/workflow-tengo:pframes")
maps := import("@platforma-sdk/workflow-tengo:maps")
pSpec := import("@platforma-sdk/workflow-tengo:pframes.spec")
text := import("text")
slices := import("@platforma-sdk/workflow-tengo:slices")

prepareFastaSw := assets.importSoftware("@platforma-open/milaboratories.clonotype-clustering.software:prepare-fasta")
processResultsSw := assets.importSoftware("@platforma-open/milaboratories.clonotype-clustering.software:process-results")
mmseqsSw := assets.importSoftware("@platforma-open/soedinglab.software-mmseqs2:main")

setTableProps := func(spec, label, visibility, orderPriority) {
	return maps.deepMerge(spec, {
		annotations: {
			"pl7.app/label": label,
			"pl7.app/table/visibility": visibility ? "default" : "optional",
			"pl7.app/table/orderPriority": orderPriority
		}
	})
}

self.validateInputs({
	"__options__,closed": "",
    emptyOrNot: "any",
    seqTable: "any",
    columns: "any",
    datasetSpec: "any",
    abundanceSpec: "any",
    identity: "number",
    similarityType: "string",
    coverageThreshold: "number",
    coverageMode: "number",
    sequencesRef: "any",
    blockId: "string"
})

self.defineOutputs("clustersPf", "msaPf", "pf", "clusterAbundanceSpec", "mmseqs", "inputState")

self.body(func(inputs) {
    clustersPf := {}
    msaPf := {}
    pf := {}
    clusterAbundanceSpec := {}
    mmseqs := {}
	inputState := {}

    seqTable := inputs.seqTable
    columns := inputs.columns
    datasetSpec := inputs.datasetSpec
    abundanceSpec := inputs.abundanceSpec
    identity := inputs.identity
    similarityType := inputs.similarityType
    coverageThreshold := inputs.coverageThreshold
    coverageMode := inputs.coverageMode
    sequencesRef := inputs.sequencesRef
    blockId := inputs.blockId

	if string(inputs.emptyOrNot.getData()) == "empty" {
		// If matrix is not full rank return empty objects
		return {
			clustersPf: clustersPf,
            msaPf: msaPf,
            pf: pf,
            clusterAbundanceSpec: clusterAbundanceSpec,
            mmseqs: mmseqs,
			inputState: {isEmpty: true}
		}

	} else {
        /***** Step 1: do clustering on the clonotype level *****/
        // prepare fasta file
        fasta := exec.builder().
            software(prepareFastaSw).
            addFile("input.tsv", seqTable).
            saveFile("output.fasta").
            run()

        // run mmseqs2
        // NOTE: mmseqs2 produces different results for same input (different line order),
        // so we save the result in the output to prevent CID conflict by deduplication
        mmseqs := exec.builder().
            software(mmseqsSw).
            dontSaveStdoutOrStderr(). // important to avoid CID conflict problems coming from different stdout output on same datasets
            arg("easy-cluster").
            arg("input.fasta").
            arg("result").
            arg("tmp").
            arg("--min-seq-id").arg(string(identity)).
            arg("-c").arg(string(coverageThreshold)).
            arg("--cov-mode").arg(string(coverageMode)).
            //  --similarity-type INT            Type of score used for clustering. 1: alignment score 2: sequence identity [2]
            arg("--similarity-type").arg(similarityType == "sequence-identity" ? "2" : "1").
            addFile("input.fasta", fasta.getFile("output.fasta")).
            saveFile("result_cluster.tsv").
            run()

        clusters := mmseqs.getFile("result_cluster.tsv")

        /******* Step 2: aggregate all data and generate results *******/
        cloneTableBuilder := pframes.tsvFileBuilder()
        cloneTableBuilder.add(columns.getColumn("abundance"), {header: "abundance"})

        for nr, seq in sequencesRef {
            cloneTableBuilder.add(columns.getColumn(seq), {header: "sequence_" + string(nr)})
        }

        cloneTableBuilder.add(columns.getColumn("clonotypeKeyLabels"), {header: "clonotypeKeyLabel"})
        // cloneTable.add("VGene", {header: "VGene"})
        // cloneTable.add("JGene", {header: "JGene"})
        cloneTableBuilder.setAxisHeader(abundanceSpec.axesSpec[0].name, "sampleId")
        cloneTableBuilder.setAxisHeader(abundanceSpec.axesSpec[1].name, "clonotypeKey")
        cloneTable := cloneTableBuilder.build()


        result := exec.builder().
            software(processResultsSw).
            addFile("clusters.tsv", clusters).
            addFile("cloneTable.tsv", cloneTable).
            saveFile("abundances.tsv").
            saveFile("cluster-to-seq.tsv").
            saveFile("clone-to-cluster.tsv").
            saveFile("abundances-per-cluster.tsv"). // cluster to summed abundances
            saveFile("distance_to_centroid.tsv"). // normalized levenshtein distance to centroid
            run()


        abundances := result.getFile("abundances.tsv")
        clusterIdAxisSpec := {
            name: "pl7.app/vdj/clusterId",
            type: "String",
            domain: maps.deepMerge(datasetSpec.axesSpec[1].domain,
            {
                "pl7.app/vdj/clustering/algorithm": "mmseqs2",
                "pl7.app/vdj/clustering/blockId": blockId
                // @TODO: add clustering parameters here
            }),
            annotations: {
                "pl7.app/label": "Cluster Id",
                "pl7.app/table/visibility": "default",
                "pl7.app/table/orderPriority": "990000"
            }
        }

        ac := {
            name: abundanceSpec.name,
            valueType: abundanceSpec.valueType,
            domain: abundanceSpec.domain,
            annotations: abundanceSpec.annotations
        }

        abundanceLabel := abundanceSpec.annotations["pl7.app/label"]

        abundancesPf := xsv.importFile(abundances, "tsv", {
            axes: [{
                column: "sampleId",
                spec: abundanceSpec.axesSpec[0]
            }, {
                column: "clusterId",
                spec: clusterIdAxisSpec
            }],
            columns: [{
                column: "abundance",
                spec: setTableProps(ac, abundanceLabel + " in cluster", false, undefined)
            },
            {
                column: "abundance_normalized",
                spec: setTableProps(maps.deepMerge(ac, {
                    valueType: "Float",
                    annotations: {
                        "pl7.app/abundance/normalized": "true"
                    }
                }), text.re_replace("Number", abundanceLabel, "Fraction") + " in cluster", false, undefined)
            }]
        }, {splitDataAndSpec: true})


        abundancesPerCluster := result.getFile("abundances-per-cluster.tsv")

        abundancesPerClusterPf := xsv.importFile(abundancesPerCluster, "tsv", {
            axes: [{
                column: "clusterId",
                spec: clusterIdAxisSpec
            }],
            columns: [{
                column: "abundance_per_cluster",
                spec: setTableProps(ac, "Total " + abundanceLabel + " in cluster", false, undefined)
            }]
        }, {splitDataAndSpec: true})

        cloneToCluster := result.getFile("clone-to-cluster.tsv")
        cloneToClusterPf := xsv.importFile(cloneToCluster, "tsv", {
            axes: [{
                column: "clonotypeKey",
                spec: datasetSpec.axesSpec[1]
            }],
            columns: [{
                column: "clusterLabel",
                spec: setTableProps({
                    name: "pl7.app/vdj/clusterId",
                    valueType: "String",
                    domain: clusterIdAxisSpec.domain,
                    annotations: clusterIdAxisSpec.annotations
                }, "Cluster Id", false, undefined)
            }]
        }, {splitDataAndSpec: true})

        cloneToClusterLinkPf := xsv.importFile(cloneToCluster, "tsv", {
            axes: [{
                column: "clonotypeKey",
                spec: datasetSpec.axesSpec[1]
            }, {
                column: "clusterId",
                spec: clusterIdAxisSpec
            }],
            columns: [{
                column: "link",
                spec: setTableProps({
                    name: "pl7.app/vdj/link",
                    valueType: "Int",
                    annotations: {
                        "pl7.app/isLinkerColumn": "true"
                    }
                }, "Clone to cluster link", false, undefined)
            }]
        }, {splitDataAndSpec: true})

        clusterToSeq := result.getFile("cluster-to-seq.tsv")

        seqColumns := [
        {
            column: "size",
            spec: {
                name: "pl7.app/vdj/clustering/clusterSize",
                valueType: "Int",
                annotations: {
                    "pl7.app/label": "Cluster Size"
                }
            }
        }, {
            column: "clusterLabel",
            spec: {
                name: "pl7.app/label",
                valueType: "String",
                annotations: {
                    "pl7.app/label": "Cluster Id"
                }
            }
        }]

        // Add sequence columns
        for nr, seq in sequencesRef {
            spec := maps.clone(columns.getSpec(seq))
            spec.annotations["pl7.app/label"] = "Centroid " + spec.annotations["pl7.app/label"]
            seqColumns = append(seqColumns, {
                column: "sequence_" + string(nr),
                spec: setTableProps({
                    name: spec.name,
                    valueType: spec.valueType,
                    domain: spec.domain,
                    annotations: spec.annotations
                }, spec.annotations["pl7.app/label"], true, "10")
            })
        }

        clusterToSeqPf := xsv.importFile(clusterToSeq, "tsv", {
            axes: [{
                column: "clusterId",
                spec: clusterIdAxisSpec
            }],
            columns: seqColumns
        }, {splitDataAndSpec: true})


        distances := result.getFile("distance_to_centroid.tsv")
        distancesPf := xsv.importFile(distances, "tsv", {
            axes: [{
                column: "clonotypeKey",
                spec: datasetSpec.axesSpec[1]
            }],
            columns: [{
                column: "distanceToCentroid",
                spec: setTableProps({
                    name: "pl7.app/vdj/distanceToCentroid",
                    valueType: "Float",
                    annotations: {
                        "pl7.app/min": "0",
                        "pl7.app/max": "1",
                        "pl7.app/rankingOrder": "decreasing",
                        "pl7.app/format": ".2f"
                    }
                }, "Distance to centroid", false, undefined)
            }]
        }, {splitDataAndSpec: true})

        // building outputs & exports
        trace := pSpec.makeTrace(abundanceSpec,
            {
                type: "milaboratories.clonotype-clustering",
                importance: 30,
                label: "Clonotype clusters"
            })

        opf := pframes.pFrameBuilder()
        for k, v in clusterToSeqPf {
            if k == "clusterLabel" {
                // avoid putting label into the outputs as it will be already in exports;
                // in future should be safe to add once PlAgDataTable bug is fixed
                continue
            }
            opf.add(k, trace.inject(v.spec), v.data)
        }
        opf = opf.build()

        // Generate pFrames with sequences
        msaPf := pframes.pFrameBuilder()
        i := 0
        for pf in [cloneToClusterLinkPf, distancesPf] {
            for k, v in pf {
                msaPf.add(k + string(i), trace.inject(v.spec), v.data) // label, specs, data
                i = i + 1
            }
        }
        msaPf = msaPf.build()


        epf := pframes.pFrameBuilder() 
        i = 0
        for pf in [abundancesPf, cloneToClusterPf, cloneToClusterLinkPf, clusterToSeqPf, abundancesPerClusterPf, distancesPf] {
            for k, v in pf {
                epf.add(k + string(i), trace.inject(v.spec), v.data) // label, specs, data
                i = i + 1
            }
        }
        epf = epf.build()

        clusterAbundanceSpec := trace.inject(abundancesPf["abundance"].spec)

		return {
			// for table
			clustersPf: opf,
			// for MSA
			msaPf: msaPf,
			// pf for plots
			pf: epf,
			// specs to outputs for visualization purposes
			clusterAbundanceSpec: clusterAbundanceSpec,

			// save mmseqs2 result in the output to enable deduplication of mmseqs2 run
			// NOTE: mmseqs2 produces different results for same input (different line order)
			mmseqs: clusters,
			inputState: {isEmpty: false}
		}
	} 
})