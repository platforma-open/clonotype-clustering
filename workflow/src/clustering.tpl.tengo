self := import("@platforma-sdk/workflow-tengo:tpl")
ll := import("@platforma-sdk/workflow-tengo:ll")
exec := import("@platforma-sdk/workflow-tengo:exec")
assets:= import("@platforma-sdk/workflow-tengo:assets")
pframes := import("@platforma-sdk/workflow-tengo:pframes")

prepareFastaSw := assets.importSoftware("@platforma-open/milaboratories.clonotype-clustering.software:prepare-fasta")
processResultsSw := assets.importSoftware("@platforma-open/milaboratories.clonotype-clustering.software:process-results")
mmseqsSw := assets.importSoftware("@platforma-open/soedinglab.software-mmseqs2:main")

self.validateInputs({
	"__options__,closed": "",
    emptyOrNot: "any",
    seqTable: "any",
    columns: "any",
    datasetSpec: "any",
    abundanceSpec: "any",
    identity: "number",
    similarityType: "string",
    coverageThreshold: "number",
    coverageMode: "number",
    sequencesRef: "any",
    "trimStart,?": "number",
    "trimEnd,?": "number",
    metaInputs: {
        "__options__,closed": "",
        "mem,?": "number",
        "cpu,?": "number"
    }
})

self.defineOutputs("abundances", "clusterToSeq", "cloneToCluster", "abundancesPerCluster", "distanceToCentroid", "clusterRadius", "clusterToSeqTop", "clusterRadiusTop", "abundancesTop", "trimmedSequences", "result", "mmseqs", "mmseqsOutput", "isEmpty")

self.body(func(inputs) {
    result := {}
    mmseqs := {}
    mmseqsOutput := {}
	isEmpty := false

    seqTable := inputs.seqTable
    columns := inputs.columns
    datasetSpec := inputs.datasetSpec
    abundanceSpec := inputs.abundanceSpec
    identity := inputs.identity
    similarityType := inputs.similarityType
    coverageThreshold := inputs.coverageThreshold
    coverageMode := inputs.coverageMode
    sequencesRef := inputs.sequencesRef
    // Treat undefined trimming values as zero (no trimming)
    trimStart := is_undefined(inputs.trimStart) ? 0 : inputs.trimStart
    trimEnd := is_undefined(inputs.trimEnd) ? 0 : inputs.trimEnd

    // Determine if single-cell and likely two chains selected
    isSingleCell := datasetSpec.axesSpec[1].name == "pl7.app/vdj/scClonotypeKey"
    perChainTrim := isSingleCell && len(sequencesRef) > 1

	if string(inputs.emptyOrNot.getData()) == "empty" {
		// If matrix is not full rank return empty objects
		return {
			abundances: {},
			clusterToSeq: {},
			cloneToCluster: {},
			abundancesPerCluster: {},
			distanceToCentroid: {},
			clusterRadius: {},
			clusterToSeqTop: {},
			clusterRadiusTop: {},
			abundancesTop: {},
			trimmedSequences: {},
			result: result,
            mmseqs: mmseqs,
            mmseqsOutput: mmseqsOutput,
			isEmpty: true
		}

	} else {
        /***** Step 1: do clustering on the clonotype level *****/
        // prepare fasta file
        fastaBuilder := exec.builder().
            software(prepareFastaSw).
            mem("16GiB").
	    cpu(1).
            addFile("input.tsv", seqTable).
            arg("--trim-start").arg(string(trimStart)).
            arg("--trim-end").arg(string(trimEnd))

        if perChainTrim {
            fastaBuilder = fastaBuilder.arg("--per-chain-trim")
        }

        fasta := fastaBuilder.
            saveFile("output.fasta").
            run()

        // get split memory limit based on real system ram
	    memLimit := "{int(ceil(system.ram.gb * 0.8))}" + "G"

        mem := "32GiB" // @TODO: set based on the size of the input
	    cpu := 16

        if !is_undefined(inputs.metaInputs.mem) {
            mem = string(inputs.metaInputs.mem) + "GiB"
        }
        if !is_undefined(inputs.metaInputs.cpu) {
            cpu = inputs.metaInputs.cpu
        }

        // run mmseqs2
        // NOTE: mmseqs2 produces different results for same input (different line order),
        // so we save the result in the output to prevent CID conflict by deduplication
        mmseqs := exec.builder().
            software(mmseqsSw).
            mem(mem).
	        cpu(cpu).
            printErrStreamToStdout(). 
            arg("easy-cluster").
            arg("input.fasta").
            arg("result").
            arg("tmp").
            arg("--split-memory-limit").argWithVar(memLimit).
            arg("--threads").argWithVar("{system.cpu}").
            arg("--min-seq-id").arg(string(identity)).
            arg("-c").arg(string(coverageThreshold)).
            arg("--cov-mode").arg(string(coverageMode)).
            //  --similarity-type INT            Type of score used for clustering. 1: alignment score 2: sequence identity [2]
            arg("--similarity-type").arg(similarityType == "sequence-identity" ? "2" : "1").
            addFile("input.fasta", fasta.getFile("output.fasta")).
            saveFile("result_cluster.tsv").
            run()

        clusters := mmseqs.getFile("result_cluster.tsv")
        mmseqsOutput := mmseqs.getStdoutStream()

        /******* Step 2: aggregate all data and generate results *******/
        cloneTableBuilder := pframes.tsvFileBuilder()
        cloneTableBuilder.add(columns.getColumn("abundance"), {header: "abundance"})

        for nr, seq in sequencesRef {
            cloneTableBuilder.add(columns.getColumn(seq), {header: "sequence_" + string(nr)})
        }

        // Get the array of label columns using the correct method
	    clonotypeKeyLabelsArray := columns.getColumns("clonotypeKeyLabels")

        // Check if we have any label columns and use the first one
        if len(clonotypeKeyLabelsArray) > 0 {
            cloneTableBuilder.add(clonotypeKeyLabelsArray[0], {header: "clonotypeKeyLabel"})
        } else {
            // Handle case where no label columns found
            ll.panic("No clonotype key label columns found")
        }
        // cloneTable.add("VGene", {header: "VGene"})
        // cloneTable.add("JGene", {header: "JGene"})
        cloneTableBuilder.setAxisHeader(abundanceSpec.axesSpec[0].name, "sampleId")
        cloneTableBuilder.setAxisHeader(abundanceSpec.axesSpec[1].name, "clonotypeKey")
        cloneTableBuilder.mem("32GiB") // @TODO: set based on the size of the input
	    cloneTableBuilder.cpu(4) // @TODO: set based on the size of the input
        cloneTable := cloneTableBuilder.build()


        resultBuilder := exec.builder().
            software(processResultsSw).
            mem("32GiB"). // @TODO: set based on the size of the input
            cpu(8). // @TODO: set based on the size of the input
            addFile("clusters.tsv", clusters).
            addFile("cloneTable.tsv", cloneTable).
            arg("--trim-start").arg(string(trimStart)).
            arg("--trim-end").arg(string(trimEnd))

        if perChainTrim {
            resultBuilder = resultBuilder.arg("--per-chain-trim")
        }

        result := resultBuilder.
            saveFile("abundances.tsv").
            saveFile("cluster-to-seq.tsv").
            saveFile("clone-to-cluster.tsv").
            saveFile("abundances-per-cluster.tsv"). // cluster to summed abundances
            saveFile("distance_to_centroid.tsv"). // normalized levenshtein distance to centroid
            saveFile("cluster-radius.tsv"). // max distance to centroid per cluster
            saveFile("cluster-to-seq-top.tsv"). // top clusters for bubble plot
            saveFile("cluster-radius-top.tsv"). // top clusters for bubble plot
            saveFile("abundances-top.tsv"). // top clusters for bubble plot
            saveFile("trimmed-sequences.tsv"). // per-clonotype trimmed sequences
            run()

		return {
			// Extract files from result for use in build-results template
			abundances: result.getFile("abundances.tsv"),
			clusterToSeq: result.getFile("cluster-to-seq.tsv"),
			cloneToCluster: result.getFile("clone-to-cluster.tsv"),
			abundancesPerCluster: result.getFile("abundances-per-cluster.tsv"),
			distanceToCentroid: result.getFile("distance_to_centroid.tsv"),
			clusterRadius: result.getFile("cluster-radius.tsv"),
			clusterToSeqTop: result.getFile("cluster-to-seq-top.tsv"),
			clusterRadiusTop: result.getFile("cluster-radius-top.tsv"),
			abundancesTop: result.getFile("abundances-top.tsv"),
			trimmedSequences: result.getFile("trimmed-sequences.tsv"),
			// Return execution result object to enable deduplication
			// The result object itself deduplicates based on execution inputs
			result: result,
			// save mmseqs2 result in the output to enable deduplication of mmseqs2 run
			// NOTE: mmseqs2 produces different results for same input (different line order)
			mmseqs: clusters,
			mmseqsOutput: mmseqsOutput,
			isEmpty: false
		}
	} 
})